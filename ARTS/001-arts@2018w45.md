# ARTS

- Algorithm：一个leetcode 算法题
- Review：点评一篇英文技术文章
- Tip：学习一个技术技巧
- Share：分享一个技术观点和思考


## Algorithm

```
105 102 100 95 92 90 

type1: 10,20, 100,
type2: 2x5 or 4x5
type3: 

```



## Review



## Tip

- 解决算法题先要建立计算模型，建立计算模型可以先进行举例：给所有类型都找到对应的例子和解决方法，防止漏掉。
- 升级测试遇到的 bug 的定位方法：
  - 查看 device log 中的 crash 日志
  - 手机上先从 AppStore 安装旧版本，再使用 xcode 安装新版本

## Share

多线程下的线程安全—— ‘互相引用’ 的对象容易出现**野指针**或**空指针**的情况，尤其是在 MRC 代码中，这周遇到的一个 bug 即是类似情况。

伪代码

```
/* 
 * class TaskPool is uesed to manage task 
 * all methods in TaskPool are called in mainQueue
 */

// add task and hod task
- (void)addTask:(Task *)task {
  [self.waitingTasks addObject:task];
}

// clean and release all tasks
- (void)cleanPool {
  self.waitingTasks = [NSArray new];
  self.runningTasks = [NSArray new]
}
```

```
/* class Task is used to manage Execoutor */

- (void)init {
  [self createExecutor];
}

- (void)createExecutor {
  self.executor = [Executor new];
  [self.executor addTask:self];
}

- (void)taskFailed:(NSError *)error {
  // first remove task from pool, prevent it stuck other tasks in the pool
  [self.pool removeTask:self];
  // perform other callback ...
}

- (void)dealloc {
  [self.executor removeTask:self];
}
```

```
/* 
 * class Executor perform the work content.
 * all Executor methods are called in workQueue.
 * first Executor is designed can hold more than one tasks.
 * but in the real logic, the relationship of task and executor allways be one to one.
 * [Utils nonRetainingArray] return an array that won't retain the object, like __unsafe_unretain object, if the object in the array is released, we can fetch a wild pointer from the array
 */

@implementation Executor {
  NSMutableArray *tasks;
}

- (void)init {
  self.tasks = [Utils nonRetainingArray];
}

- (void)addTask:(Task *)task {
  [self.task addObject:task];
}

- (void)removeTask:(Task *)task {
  [self.task removeObject:task];
}

- (void)executorFailed:(NSError *) {
  NSMutableArray *tmpTasks = [Utils nonRetainingArray];
  // crash because task is nil now, it's released in the main thread, what we got is wild pointer
  for (id __weak task in self.tasks) {
    [tmpTasks addObject:task];
  }
  for (Task *task in tmpTasks) {
	if([task responseToSelector:@selector(executorFailed:)) {
      [task performSelecotr:@selector(executorFailed:)];
    }
  }
  // this part code looks weird because it's copied from MRC Macro，it's try to make memory manager more easily
}

```

```
/* crash usage */

// this method called in mainQueue
- (void)stop{
  [taskPool cleanPool];
}
```

[crash 场景]

主线程调用 TaskPool 的 cleanPool 方法，清除所有的 task，释放所有的 task；同时工作线程中 executor 的失败方法 executorFailed: 正在执行，当运行到 [tmpTasks addObject:task]; 时，task 已经被释放，我们获取到的是一个野指针，此时会出现 crash。

[历史原因]

旧代码使用的 MRC 的操作方式管理对象，以前项目全部运行在主线程没有问题，但是项目中后续增加了支持多线程，导致出现新的crash。crash 只有特殊使用场景和运行场景才会出现：在 cleanPool 的同时有 executor 调用回调，所以代码上线几个月之后才发现这个 crash。

[问题分析]

整个项目完全使用 ARC，但这部分对于 nonRetainingArray 的使用完全是 MRC 的逻辑，且不适用多线程的方式。

[问题解决]

使用 NSHashTable + NSHashTableWeakMemory 代替 nonRetainingArray，NSHashTable + NSHashTableWeakMemory 不会修改 HashTable 容器内对象元素的引用计数，并且对象释放后会自动移除，此时不会出现野指针的情况，因为对象默认有原子锁，所以不用考虑同时读写 NSHashTable 的风险，同时 hashTable 和 nonRetainingArray 有相同的方法，不需要修改调用，能保证改动最小。

```
/* class Task is used to manage Execoutor */

- (void)dealloc {
	// don't need [self.executor removeTask:self], because hashTable will auto remove nil object 
}
```

```
/* class Executor perform the work content. */

@implementation Executor {
  NSHashTable *tasks;
}

- (void)init {
  self.tasks = [NSHashTable hashTableWithOptions:NSHashTableWeakMemory];;
}

- (void)executorFailed:(NSError *) {
  for (Task *task in tmpTasks) {
    if([task responseToSelector:@selector(executorFailed:)) {
      [task performSelecotr:@selector(executorFailed:)];
    }
  }
}
```
